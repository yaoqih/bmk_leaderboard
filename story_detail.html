<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-lang-key="story_detail_title">Result Explorer - Storytelling Benchmark</title>
    <link rel="stylesheet" href="css/style.css">
    <style>
        /* Add specific styles for story detail page */
        .input-section {
            display: flex;
            gap: 30px;
            margin-bottom: 20px;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }
        .input-section > div {
            flex: 1; /* Share space */
            min-width: 300px; /* Minimum width before wrapping */
        }
         .character-refs img {
            max-width: 80px; /* Smaller images for refs */
            margin: 5px;
            border: 1px solid #ccc;
            vertical-align: middle;
        }
        .model-selector label {
            margin-right: 15px;
        }

        /* Carousel Styles (Removed, replaced by vertical sequences) */

        /* Style for highlighting characters relevant to current shot */
        .character-refs .relevant-char {
            border: 2px solid #77aaff;
            box-shadow: 0 0 5px #77aaff;
        }

        /* Story Selector Styles */
        .story-selector {
            margin-bottom: 25px;
            padding: 15px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        .story-selector h3 {
            margin-top: 0;
            margin-bottom: 10px;
        }
        .story-tabs {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .story-tabs button {
            padding: 8px 15px;
            cursor: pointer;
            border: 1px solid #ccc;
            background-color: #fff;
            border-radius: 4px;
            transition: background-color 0.2s, border-color 0.2s;
        }
        .story-tabs button.active {
            background-color: #77aaff;
            color: white;
            border-color: #5588cc;
        }
        .story-tabs button:hover:not(.active) {
            background-color: #e9e9e9;
        }

        /* Story Wall Styles */
        .story-wall-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px; /* Gap between cards */
            justify-content: center; /* Center cards if they don't fill the row */
            padding: 10px;
            min-height: 250px; /* Ensure it has some height during loading */
        }
        .story-card {
            width: 150px; /* Width of each card */
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: box-shadow 0.3s ease, transform 0.3s ease;
            background-color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .story-card:hover {
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            transform: translateY(-5px);
        }
        .story-card img {
            width: 100%;
            height: 180px; /* Fixed height for the image part */
            object-fit: cover; /* Crop image to fit, maintaining aspect ratio */
            border-radius: 4px;
            margin-bottom: 8px;
            background-color: #f0f0f0; /* Placeholder background */
        }
        .story-card .story-name {
            font-size: 0.9em;
            font-weight: bold;
            color: #333;
            margin-top: auto; /* Push name to bottom if card content varies */
        }
        /* Style for the active story card */
        .story-card.active {
            border-color: #77aaff;
            box-shadow: 0 0 10px rgba(119, 170, 255, 0.5);
            transform: translateY(0); /* Override hover transform */
        }

        .story-pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 20px;
            gap: 10px;
        }
        .story-pagination button {
            padding: 8px 15px;
            cursor: pointer;
            border: 1px solid #ccc;
            background-color: #f8f8f8;
            border-radius: 4px;
        }
        .story-pagination button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        .story-pagination #page-info {
            font-size: 0.9em;
            color: #555;
        }

        /* Model Sequence Styles */
        .model-results-area {
            margin-top: 20px;
        }
        .model-sequence-container {
            margin-bottom: 30px;
            border: 1px solid #ddd;
            padding: 15px;
            background-color: #fdfdfd;
            border-radius: 5px;
        }
        .model-sequence-container h4 {
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.1em;
        }
        .image-sequence-scroll-container {
            display: flex;
            overflow-x: auto; /* Horizontal scroll */
            overflow-y: hidden; /* Hide vertical scrollbar */
            gap: 10px;
            padding-bottom: 15px; /* Space for scrollbar */
            white-space: nowrap; /* Prevent wrapping */
            align-items: center; /* Align images vertically */
            min-height: 150px; /* Ensure container has height even when empty */
            background-color: #f9f9f9;
            border: 1px solid #eee;
            border-radius: 4px;
        }
        .image-sequence-scroll-container img {
            max-height: 200px; /* Limit image height */
            width: auto; /* Maintain aspect ratio */
            display: inline-block; /* Needed for nowrap */
            border: 2px solid transparent;
            cursor: pointer;
            transition: border-color 0.3s, transform 0.3s;
        }
        .image-sequence-scroll-container img.focused {
            border-color: #77aaff;
            transform: scale(1.05);
            box-shadow: 0 0 8px rgba(119, 170, 255, 0.5);
        }

        /* Global Controls Styles */
        .global-controls {
             display: flex;
             justify-content: space-between;
             align-items: center;
            margin-top: 15px;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f9f9f9;
            border: 1px solid #eee;
            border-radius: 5px;
         }
        .global-controls button {
             padding: 8px 15px;
             cursor: pointer;
             background-color: #555;
             color: white;
             border: none;
             border-radius: 3px;
         }
        .global-controls button:hover {
             background-color: #77aaff;
         }
        .carousel-timer { /* Using same class for simplicity */
             width: 60%;
             height: 10px;
             background-color: #ddd;
             border-radius: 5px;
             overflow: hidden; /* For progress bar */
         }
        .carousel-progress { /* Using same class for simplicity */
             width: 0; /* Controlled by JS */
             height: 100%;
             background-color: #77aaff;
             transition: width 0.1s linear; /* Smooth progress */
         }

        /* Model Configuration Styles */
        .model-config {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 4px;
        }
        .model-config label {
            font-weight: bold;
            margin-right: 5px;
        }
        .model-config select {
            padding: 5px 8px;
            border: 1px solid #ccc;
            border-radius: 3px;
            min-width: 120px; /* Ensure dropdowns have some width */
         }

    </style>
</head>
<body>
    <header>
        <nav>
            <ul>
                <li><a href="index.html" data-lang-key="nav_overview">Overview</a></li>
                <li><a href="leaderboard_detail.html" data-lang-key="nav_leaderboard_detail">Detailed Leaderboard</a></li>
                <li><a href="metrics.html" data-lang-key="nav_metrics">Metrics Definition</a></li>
                <li><a href="dataset.html" data-lang-key="nav_dataset">Dataset</a></li>
                <li><a href="story_detail.html" class="active" data-lang-key="nav_explorer">Result Explorer</a></li>
            </ul>
            <div class="lang-switcher">
                <button id="lang-en-btn">English</button>
                <button id="lang-zh-btn">中文</button>
            </div>
        </nav>
        <h1 id="story-detail-main-title" data-lang-key="story_detail_title">Result Explorer: Story [Story ID]</h1>
    </header>

    <main>
        <!-- Story Selector -->
        <section id="story-selector-section" class="story-selector">
            <h3 data-lang-key="select_story_title">Select Story:</h3>
            <div id="story-wall-container" class="story-wall-container">
                <!-- JS will populate this with story cards -->
                <p>Loading stories...</p>
            </div>
            <div id="story-pagination-controls" class="story-pagination">
                <button id="prev-page-btn" data-lang-key="prev_page">Previous</button>
                <span id="page-info">Page X of Y</span>
                <button id="next-page-btn" data-lang-key="next_page">Next</button>
            </div>
        </section>

        <section id="input-info" class="input-section">
            <div>
                <h3 data-lang-key="input_script">Input Script</h3>
                <div id="script-details-area">
                    <!-- JS will populate this area -->
                    <h4 data-lang-key="script_plot">Plot Correspondence</h4>
                    <p id="script-plot-display">[Select a story to load script]</p>
                    <h4 data-lang-key="script_setting">Setting Description</h4>
                    <p id="script-setting-display">-</p>
                    <h4 data-lang-key="script_perspective">Shot Perspective Design</h4>
                    <p id="script-perspective-display">-</p>
                    <h4 data-lang-key="script_static_desc">Static Shot Description</h4>
                    <p id="script-static-desc-display">-</p>
                </div>
                <p><strong id="shot-indicator-text" data-lang-key="shot_current_of_total">Shot [?] of [?]</strong></p>
            </div>
            <div>
                <h3 data-lang-key="character_ref">Character Reference</h3>
                <div class="character-refs" id="character-reference-area">
                    <!-- JS will populate this -->
                    <p>Select a story to load characters.</p>
                </div>
            </div>
        </section>

        <!-- Global Controls -->
         <section class="global-controls">
             <button id="prev-shot-btn" onclick="changeShot(-1)" data-lang-key="prev_shot" disabled>Previous Shot</button>
             <div class="carousel-timer">
                 <div class="carousel-progress" id="carousel-progress-bar"></div>
             </div>
             <button id="next-shot-btn" onclick="changeShot(1)" data-lang-key="next_shot" disabled>Next Shot</button>
         </section>

         <!-- Model Selection Removed - Configuration is per-model now -->

        <!-- Vertically Stacked Model Sequences -->
        <section id="model-results-area">
             <!-- JS will populate this area based on selected story and models -->
            <p>Select a story and models to view results.</p>
             <!-- Example Structure (Generated by JS) -->
<!--              
             <div class="model-sequence-container" data-model-key="storygen">
                 <h4>StoryGen</h4>
                 <div class="model-config">
                     <div>
                         <label for="mode-select-storygen">Mode:</label>
                         <select id="mode-select-storygen" onchange="handleConfigChange('storygen')">
                             <option value="sd3">sd3</option>
                             <option value="other_mode">other_mode</option>
                         </select>
                     </div>
                     <div>
                         <label for="lang-select-storygen">Language:</label>
                         <select id="lang-select-storygen" onchange="handleConfigChange('storygen')">
                             <option value="en">en</option>
                             <option value="ch">ch</option>
                         </select>
                     </div>
                     <div>
                         <label for="ts-select-storygen">Timestamp:</label>
                         <select id="ts-select-storygen" onchange="handleTimestampChange('storygen')">
                             <option value="20250430-022517">20250430-022517</option>
                         </select>
                     </div>
                 </div>
                 <div class="image-sequence-scroll-container">
                     <p>Loading images...</p>
                 </div>
             </div>
             -->
        </section>

    </main>

    <footer>
        <p data-lang-key="footer_text">Storytelling Benchmark © 2025</p>
    </footer>

    <!-- Remove placeholder data script -->
    <script src="data/placeholder_data.js"></script>
    <script src="js/main.js"></script>
    <!-- Updated JS below -->

    <script>
        // --- Result Explorer Specific JS ---

        // --- Configuration & State ---
        const DATA_BASE_PATH = 'data'; // Base path for datasets and outputs
        let currentStoryData = null; // Holds the loaded story.json content
        let currentStoryId = null; // e.g., "WildStory_en_01"
        let currentDataset = null; // e.g., "WildStory_en"
        let availableStories = []; // Will be populated from manifest/config
        let detailedManifest = null; // Will hold the parsed detailed_manifest.json
        let currentShotIndex = 0;
        let totalShots = 0;
        let autoPlayTimer = null;
        const autoPlayInterval = 5000; // 5 seconds
        let progressInterval = null;

        // Pagination State
        let currentPage = 1;
        const storiesPerPage = 10; // Adjust as needed
        let totalStoryPages = 0;

        // --- DOM References ---
        const storyTabsContainer = document.getElementById('story-tabs-container'); // This will be replaced by storyWallContainer
        const storyWallContainer = document.getElementById('story-wall-container');
        const prevPageBtn = document.getElementById('prev-page-btn');
        const nextPageBtn = document.getElementById('next-page-btn');
        const pageInfoDisplay = document.getElementById('page-info');

        const storyTitleElement = document.getElementById('story-detail-main-title');
        const shotIndicatorText = document.getElementById('shot-indicator-text');
        const progressBar = document.getElementById('carousel-progress-bar');
        const characterReferenceArea = document.getElementById('character-reference-area');
        const modelResultsArea = document.getElementById('model-results-area');
        const prevShotBtn = document.getElementById('prev-shot-btn');
        const nextShotBtn = document.getElementById('next-shot-btn');

        // --- Data Fetching ---
        async function fetchStoryData(storyId) {
             if (!detailedManifest || !detailedManifest.stories) {
                 console.error("Detailed manifest not loaded yet.");
                 return null;
             }
            const storyInfo = detailedManifest.stories.find(s => s.id === storyId);
            if (!storyInfo) {
                console.error(`Story info not found for ID: ${storyId}`);
                return null;
            }
            currentDataset = storyInfo.dataset_base; // Store the BASE dataset name (e.g., WildStory)
            const storyJsonPath = `${DATA_BASE_PATH}/datasets/${currentDataset}/${storyInfo.id}/story.json`;
            console.log(`Fetching story data from: ${storyJsonPath}`);
            try {
                const response = await fetch(storyJsonPath);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error("Error fetching story data:", error);
                characterReferenceArea.innerHTML = `<p>Error loading character data.</p>`;
                modelResultsArea.innerHTML = `<p>Error loading results.</p>`;
                return null;
            }
        }

        // --- UI Update Functions ---

        function populateStorySelector() {
            // This function is now for the story wall with pagination
            storyWallContainer.innerHTML = ''; // Clear loading message or previous cards

            if (!availableStories || availableStories.length === 0) {
                 storyWallContainer.innerHTML = '<p>No stories found in manifest.</p>';
                 document.getElementById('story-pagination-controls').style.display = 'none';
                 return;
            }
            document.getElementById('story-pagination-controls').style.display = 'flex';

            totalStoryPages = Math.ceil(availableStories.length / storiesPerPage);
            const startIndex = (currentPage - 1) * storiesPerPage;
            const endIndex = startIndex + storiesPerPage;
            const storiesToDisplay = availableStories.slice(startIndex, endIndex);

            if (storiesToDisplay.length === 0 && currentPage > 1) { // If current page is empty (e.g. after deleting last item on last page)
                currentPage--; // Go to previous page
                populateStorySelector(); // Re-render
                return;
            }

            storiesToDisplay.forEach(story => {
                const card = document.createElement('div');
                card.classList.add('story-card');
                card.setAttribute('data-story-id', story.id);
                card.onclick = () => loadStory(story.id);

                const img = document.createElement('img');
                // Attempt to use cover_image_path from manifest (assuming it will be added)
                // If not, use a placeholder or fetch dynamically (more complex, for later)
                img.src = story.cover_image_path || 'img/placeholder_story_cover.png'; // Ensure this placeholder exists
                img.alt = story.name;
                img.onerror = () => { img.src = 'img/placeholder_story_cover.png'; }; // Fallback on error

                const name = document.createElement('p');
                name.classList.add('story-name');
                name.textContent = story.story_type_en+'('+story.name+')'+' ';

                card.appendChild(img);
                card.appendChild(name);
                storyWallContainer.appendChild(card);
            });

            updatePaginationControls();
        }

        function updatePaginationControls() {
            if (!pageInfoDisplay || !prevPageBtn || !nextPageBtn) return;

            if (totalStoryPages <= 0) {
                document.getElementById('story-pagination-controls').style.display = 'none';
                return;
            }
             document.getElementById('story-pagination-controls').style.display = 'flex';

            pageInfoDisplay.textContent = `Page ${currentPage} of ${totalStoryPages}`;
            prevPageBtn.disabled = currentPage === 1;
            nextPageBtn.disabled = currentPage === totalStoryPages || totalStoryPages === 0;
        }

        function changeStoryPage(direction) {
            currentPage += direction;
            if (currentPage < 1) currentPage = 1;
            if (currentPage > totalStoryPages) currentPage = totalStoryPages;
            populateStorySelector(); // Re-render the story wall for the new page
        }

        function updateCharacterReferences() {
            characterReferenceArea.innerHTML = ''; // Clear previous
             if (!currentStoryData || !currentStoryData.Characters) {
                 characterReferenceArea.innerHTML = '<p>No character data found.</p>';
                 return;
             }
             const currentLang = document.documentElement.lang || 'en';

             Object.entries(currentStoryData.Characters).forEach(([charKey, charData]) => {
                 const charDiv = document.createElement('div');
                 const charName = charData[`name_${currentLang}`] || charData.name_en || charKey; // Get translated name
                 charDiv.setAttribute('data-char-key', charKey); // Use the original key for association
                 charDiv.innerHTML = `<strong>${charName}:</strong> `;

                 // --- Image Loading Logic (Using ref_images from story.json) ---
                 const imageBasePath = `${DATA_BASE_PATH}/datasets/${currentDataset}/${currentStoryId}/image/${charKey}/`;

                 if (charData.ref_images && Array.isArray(charData.ref_images) && charData.ref_images.length > 0) {
                     charData.ref_images.forEach((imageFilename, index) => {
                         const imgSrc = `${imageBasePath}${imageFilename}`; // Use the filename directly

                         const img = document.createElement('img');
                         img.src = imgSrc;
                         img.alt = `${charName} Ref ${index + 1}`;
                         img.setAttribute('data-char-key', charKey);
                         img.onerror = () => { img.style.display = 'none'; }; // Hide if load fails
                         charDiv.appendChild(img);
                     });
                 } else {
                     // Add a fallback if ref_images is missing, not an array, or empty
                     charDiv.appendChild(document.createTextNode(' [No reference images listed]'));
                 }

                 // Check if any images were actually loaded and are visible
                 // This check might be less necessary now, but kept for robustness
                 if (charDiv.querySelectorAll('img:not([style*="display: none"])').length === 0 && (!charData.ref_images || charData.ref_images.length === 0)) {
                    // If no images listed AND none are visible, the fallback text should already be there or added above.
                    // We could potentially refine the fallback logic if needed.
                 } else if (charDiv.querySelectorAll('img:not([style*="display: none"])').length === 0 && charData.ref_images && charData.ref_images.length > 0) {
                     // This case means images were listed but *all* failed to load.
                     charDiv.appendChild(document.createTextNode(' [Images failed to load]'));
                 }

                 characterReferenceArea.appendChild(charDiv);
             });
        }

        async function populateModelContainers() {
            modelResultsArea.innerHTML = ''; // Clear placeholders/previous results
            if (!currentStoryData || !detailedManifest || !detailedManifest.outputs || !currentStoryId) {
                 modelResultsArea.innerHTML = '<p>Cannot display models: Story data or manifest missing/invalid.</p>';
                 console.error("Missing data for populateModelContainers", currentStoryData, detailedManifest, currentStoryId);
                 return;
            }

            // ---> Define and check storyInfo EARLIER <---
            const storyInfo = detailedManifest.stories.find(s => s.id === currentStoryId);
            console.log("Attempting to find storyInfo for ID:", currentStoryId, "Result:", storyInfo); // Debug log

            if (!storyInfo) {
                 modelResultsArea.innerHTML = `<p>Internal error: Could not find story info for ID '${currentStoryId}' in manifest.</p>`;
                 console.error("Could not find story info for ID:", currentStoryId, "in manifest stories:", detailedManifest.stories);
                 return;
            }

            const currentLang = document.documentElement.lang || 'en';
            const datasetBase = storyInfo.dataset_base; // datasetBase is available now

             // Iterate through methods (models) available in the manifest outputs
            Object.keys(detailedManifest.outputs).forEach(modelKey => {
                const modelData = detailedManifest.outputs[modelKey];

                const modelContainer = document.createElement('div');
                modelContainer.classList.add('model-sequence-container');
                modelContainer.setAttribute('data-model-key', modelKey);

                const title = document.createElement('h4');
                // Use translated model name if available, else fallback
                 const modelNameKey = `model_${modelKey}`; // e.g., model_storygen
                 const modelName = translations[currentLang]?.[modelNameKey] || modelKey; // Fallback to key
                title.textContent = modelName;
                modelContainer.appendChild(title);

                // --- Create Config Section ---
                const configDiv = document.createElement('div');
                configDiv.classList.add('model-config');

                // Mode Dropdown
                const modes = Object.keys(modelData);
                const modeSelect = createDropdown(modelKey, 'mode', 'Mode', modes);
                configDiv.appendChild(modeSelect);

                // Language Dropdown (depends on selected mode and story)
                const langSelect = createDropdown(modelKey, 'lang', 'Language', []); // Initially empty
                configDiv.appendChild(langSelect);

                // Timestamp Dropdown (depends on selected mode, lang, and story)
                const tsSelect = createDropdown(modelKey, 'ts', 'Timestamp', []); // Initially empty
                configDiv.appendChild(tsSelect);

                modelContainer.appendChild(configDiv);

                // --- Image Sequence Container ---
                const scrollContainer = document.createElement('div');
                scrollContainer.classList.add('image-sequence-scroll-container');
                scrollContainer.innerHTML = '<p>Select configuration to load images.</p>'; // Initial message
                modelContainer.appendChild(scrollContainer);

                modelResultsArea.appendChild(modelContainer);

                // --- Initial Population of Dependent Dropdowns & Load Images ---
                updateDependentDropdowns(modelKey); // Populate lang/ts based on default mode
            });

             // Initial call to update focused elements for the first shot
             updateExplorerView(currentShotIndex);
        }

        // --- Helper to Create Dropdown ---
        function createDropdown(modelKey, type, labelText, options) {
            const div = document.createElement('div');
            const label = document.createElement('label');
            label.setAttribute('for', `${type}-select-${modelKey}`);
            label.textContent = `${labelText}:`;

            const select = document.createElement('select');
            select.id = `${type}-select-${modelKey}`;
            select.setAttribute('data-model-key', modelKey); // Store model key for easy access
            select.onchange = () => handleConfigChange(modelKey, type); // Trigger update on change

            options.forEach(optionValue => {
                const option = document.createElement('option');
                option.value = optionValue;
                option.textContent = optionValue;
                select.appendChild(option);
            });

            div.appendChild(label);
            div.appendChild(select);
            return div;
        }

        // --- Handle Dropdown Changes ---
        function handleConfigChange(modelKey, changedType) {
            console.log(`Config changed for ${modelKey}: ${changedType}`);
            updateDependentDropdowns(modelKey);
        }

        // --- Update Language and Timestamp Dropdowns Based on Mode ---
        function updateDependentDropdowns(modelKey) {
             const modelContainer = modelResultsArea.querySelector(`.model-sequence-container[data-model-key="${modelKey}"]`);
             if (!modelContainer || !detailedManifest) return;

             const modeSelect = modelContainer.querySelector(`#mode-select-${modelKey}`);
             const langSelect = modelContainer.querySelector(`#lang-select-${modelKey}`);
             const tsSelect = modelContainer.querySelector(`#ts-select-${modelKey}`);
             const storyInfo = detailedManifest.stories.find(s => s.id === currentStoryId);

             if (!modeSelect || !langSelect || !tsSelect || !storyInfo) return;

             const selectedMode = modeSelect.value;
             const datasetBase = storyInfo.dataset_base;
             const storyId = storyInfo.id;

             // Get available languages for this mode/dataset/story
             const availableLangs = detailedManifest.outputs[modelKey]?.[selectedMode]?.[datasetBase]
                 ? Object.keys(detailedManifest.outputs[modelKey][selectedMode][datasetBase])
                 : [];

             // Populate Language Dropdown
             const currentLangVal = langSelect.value; // Preserve selection if possible
             langSelect.innerHTML = ''; // Clear options
             availableLangs.forEach(lang => {
                  // Only add language if results exist for the current story ID
                  if (detailedManifest.outputs[modelKey]?.[selectedMode]?.[datasetBase]?.[lang]?.[storyId]?.length > 0) {
                     const option = document.createElement('option');
                     option.value = lang;
                     option.textContent = lang;
                     langSelect.appendChild(option);
                  }
             });
             // Try to restore previous selection or default to first
             if (availableLangs.includes(currentLangVal) && langSelect.querySelector(`option[value="${currentLangVal}"]`)) {
                 langSelect.value = currentLangVal;
             } else if (langSelect.options.length > 0) {
                 langSelect.selectedIndex = 0;
             }

             // Populate Timestamp Dropdown (based on selected mode AND language)
             updateTimestampDropdown(modelKey); // Separate function as it depends on lang too
        }

        // --- Update Timestamp Dropdown Based on Mode and Language ---
        function updateTimestampDropdown(modelKey) {
             const modelContainer = modelResultsArea.querySelector(`.model-sequence-container[data-model-key="${modelKey}"]`);
             if (!modelContainer || !detailedManifest) return;

             const modeSelect = modelContainer.querySelector(`#mode-select-${modelKey}`);
             const langSelect = modelContainer.querySelector(`#lang-select-${modelKey}`);
             const tsSelect = modelContainer.querySelector(`#ts-select-${modelKey}`);
             const storyInfo = detailedManifest.stories.find(s => s.id === currentStoryId);

             if (!modeSelect || !langSelect || !tsSelect || !storyInfo) return;

             const selectedMode = modeSelect.value;
             const selectedLang = langSelect.value;
             const datasetBase = storyInfo.dataset_base;
             const storyId = storyInfo.id;

             // Get available timestamps
             const availableTimestamps = detailedManifest.outputs[modelKey]?.[selectedMode]?.[datasetBase]?.[selectedLang]?.[storyId] || [];

             // Populate Timestamp Dropdown
             const currentTsVal = tsSelect.value; // Preserve selection
             tsSelect.innerHTML = ''; // Clear options
             availableTimestamps.forEach(ts => {
                 const option = document.createElement('option');
                 option.value = ts;
                 option.textContent = ts;
                 tsSelect.appendChild(option);
             });
             // Try to restore previous selection or default to first
             if (availableTimestamps.includes(currentTsVal)) {
                 tsSelect.value = currentTsVal;
             } else if (tsSelect.options.length > 0) {
                 tsSelect.selectedIndex = 0;
             }

              // --- Trigger image loading for this model ---
             loadModelSequence(modelKey);
        }

         // --- Load Image Sequence for a Specific Model Container ---
         function loadModelSequence(modelKey) {
             const modelContainer = modelResultsArea.querySelector(`.model-sequence-container[data-model-key="${modelKey}"]`);
             const modeSelect = modelContainer.querySelector(`#mode-select-${modelKey}`);
             const langSelect = modelContainer.querySelector(`#lang-select-${modelKey}`);
             const tsSelect = modelContainer.querySelector(`#ts-select-${modelKey}`);
             const scrollContainer = modelContainer.querySelector('.image-sequence-scroll-container');
             const storyInfo = detailedManifest.stories.find(s => s.id === currentStoryId); // Re-fetch storyInfo for dataset_base

             if (!modeSelect || !langSelect || !tsSelect || !scrollContainer || !storyInfo || !modeSelect.value || !langSelect.value || !tsSelect.value) {
                  console.warn(`Cannot load sequence for ${modelKey}: Missing config or elements.`);
                  scrollContainer.innerHTML = '<p>Incomplete configuration.</p>';
                  return;
              }

             scrollContainer.innerHTML = '<p>Loading images...</p>'; // Show loading state

             const selectedMode = modeSelect.value;
             const selectedLang = langSelect.value;
             const selectedTimestamp = tsSelect.value;
             const datasetBase = storyInfo.dataset_base;
             const fullDatasetName = `${datasetBase}_${selectedLang}`; // Construct e.g., WildStory_en

             // Check if shots exist before proceeding
             if (!currentStoryData.Shots || currentStoryData.Shots.length === 0) {
                 scrollContainer.innerHTML = '<p>No shots defined for this story.</p>';
                 return;
             }

             // Clear previous images before adding new ones
             scrollContainer.innerHTML = '';

             // Get model display name for alt text
             const currentLang = document.documentElement.lang || 'en';
             const modelNameKey = `model_${modelKey}`;
             const modelName = translations[currentLang]?.[modelNameKey] || modelKey;

             currentStoryData.Shots.forEach((shot, index) => {
                 const img = document.createElement('img');
                 // Construct the complex image path
                 const shotIndexStr = shot.index.toString().padStart(2, '0');
                 const imagePath = `${DATA_BASE_PATH}/outputs/${modelKey}/${selectedMode}/${fullDatasetName}/${currentStoryId}/${selectedTimestamp}/shot_${shotIndexStr}.png`; // 只支持jpg格式

                 img.src = imagePath;
                 img.alt = `Model ${modelName} - Shot ${shot.index}`;
                 img.classList.add('sequence-image');
                 img.setAttribute('data-shot-index', index); // Use the array index (0-based) for internal logic
                 img.setAttribute('data-shot-id', shot.index); // Store the actual shot ID/number from JSON
                 img.addEventListener('click', handleImageClick);
                 // Basic error handling
                 img.onerror = () => {
                      console.log(imagePath);
                      img.alt = `Error loading ${modelName} - Shot ${shot.index}`;
                      // Optionally hide or replace with a placeholder visually
                      // img.style.display = 'none';
                       img.src = 'img/placeholder_error.png'; // Show a generic error image
                  };
                 scrollContainer.appendChild(img);
             });

             // After loading images, ensure the correct one is focused
             updateFocusInContainer(modelContainer, currentShotIndex);
         }

         // Helper to update focus and scroll within a single model container
         function updateFocusInContainer(container, shotIndex) {
             if (!container) return;
             let foundFocused = false;
             container.querySelectorAll('.sequence-image').forEach(img => {
                 if (parseInt(img.dataset.shotIndex) === shotIndex) {
                     img.classList.add('focused');
                     requestAnimationFrame(() => {
                        const scrollContainer = container.querySelector('.image-sequence-scroll-container');
                        if (scrollContainer && img) {
                            const containerRect = scrollContainer.getBoundingClientRect();
                            const imgRect = img.getBoundingClientRect();

                            // 计算图片中心点相对于容器左边缘的期望位置
                            const desiredImgLeftInContainer = (containerRect.width - imgRect.width) / 2;
                            // 计算当前图片左边缘相对于容器左边缘的实际位置
                            const currentImgLeftInContainer = imgRect.left - containerRect.left;
                            
                            // 计算需要滚动的量
                            const scrollAmount = currentImgLeftInContainer - desiredImgLeftInContainer;

                            // 平滑滚动（可选，需要自定义动画或使用库）
                            // scrollContainer.scrollLeft += scrollAmount; // 直接跳转

                            // 使用平滑滚动 API (如果支持且你只关心最新浏览器)
                            scrollContainer.scrollTo({
                                left: scrollContainer.scrollLeft + scrollAmount,
                                behavior: 'smooth'
                            });
                        }
                     });
                     foundFocused = true;
                 } else {
                     img.classList.remove('focused');
                 }
             });
             if (!foundFocused) {
                 console.warn(`Focused image for shot index ${shotIndex} not found in model ${container.dataset.modelKey}`);
             }
         }

        // --- Core Update Function ---
        function updateExplorerView(shotIndex) {
              if (!currentStoryData || !currentStoryData.Shots || shotIndex < 0 || shotIndex >= totalShots) {
                 console.warn("updateExplorerView: Aborting - Invalid shotIndex or no story data.", shotIndex, currentStoryData);
                 return;
              }
              console.log(`updateExplorerView called for shotIndex: ${shotIndex}`); // Log function call

              currentShotIndex = shotIndex;
              const shot = currentStoryData.Shots[currentShotIndex];
              const currentUiLang = document.documentElement.lang || 'en';

              // 1. Update Script Display
              const plotDisplay = document.getElementById('script-plot-display');
              const settingDisplay = document.getElementById('script-setting-display');
              const perspectiveDisplay = document.getElementById('script-perspective-display');
              const staticDescDisplay = document.getElementById('script-static-desc-display');

              const plotText = shot['Plot Correspondence']?.[currentUiLang] || shot['Plot Correspondence']?.['en'] || "-";
              console.log("  Plot Text:", plotText, "Element:", plotDisplay); // Log text and element
              const settingText = shot['Setting Description']?.[currentUiLang] || shot['Setting Description']?.['en'] || "-";
              console.log("  Setting Text:", settingText, "Element:", settingDisplay); // Log text and element
              const perspectiveText = shot['Shot Perspective Design']?.[currentUiLang] || shot['Shot Perspective Design']?.['en'] || "-";
              console.log("  Perspective Text:", perspectiveText, "Element:", perspectiveDisplay); // Log text and element
              const staticDescText = shot['Static Shot Description']?.[currentUiLang] || shot['Static Shot Description']?.['en'] || "-";
              console.log("  Static Desc Text:", staticDescText, "Element:", staticDescDisplay); // Log text and element

              if (plotDisplay) plotDisplay.textContent = plotText;
              if (settingDisplay) settingDisplay.textContent = settingText;
              if (perspectiveDisplay) perspectiveDisplay.textContent = perspectiveText;
              if (staticDescDisplay) staticDescDisplay.textContent = staticDescText;

              // 2. Update Shot Indicator Text
              const indicatorTextKey = 'shot_current_of_total';
              let indicatorText = translations[currentUiLang]?.[indicatorTextKey] || translations.en[indicatorTextKey];
              indicatorText = indicatorText.replace('[Current Shot]', shot.index).replace('[Total Shots]', totalShots);
              shotIndicatorText.textContent = indicatorText;

              // 3. Update Character Reference Highlighting
              characterReferenceArea.querySelectorAll('img').forEach(img => img.classList.remove('relevant-char'));
               const charactersInShot = shot['Characters Appearing']?.[currentUiLang] || shot['Characters Appearing']?.['en'] || [];

                if (charactersInShot.length > 0) {
                   // Need to map appearing character names (e.g., "大卫") back to the keys used in Characters object (e.g., "David")
                   const charKeyMap = {};
                    Object.entries(currentStoryData.Characters).forEach(([key, charData]) => {
                        charKeyMap[charData.name_en] = key;
                        charKeyMap[charData.name_ch] = key;
                    });

                    charactersInShot.forEach(charName => {
                       const charKey = charKeyMap[charName];
                       if(charKey) {
                            characterReferenceArea.querySelectorAll(`img[data-char-key="${charKey}"]`).forEach(img => {
                               // Ensure image is visible before adding class
                               if (img.offsetParent !== null) { // Check if image is displayed
                          img.classList.add('relevant-char');
                               }
                       });
                         } else {
                             console.warn(`Could not find key for character name: ${charName}`);
                         }
                    });
                }


                // 4. Update Focus in All Visible Model Sequences
                modelResultsArea.querySelectorAll('.model-sequence-container').forEach(container => {
                    if (container.style.display !== 'none') { // Only update visible models
                         updateFocusInContainer(container, currentShotIndex);
                    }
                });

                // 5. Update Progress Bar & Reset Timer
                 resetAutoPlayTimer();

                  // 6. Enable/Disable Buttons
                  prevShotBtn.disabled = (totalShots <= 0);
                  nextShotBtn.disabled = (totalShots <= 0);
         }

          // --- Load Story Function ---
          async function loadStory(storyId) {
              console.log(`Loading story: ${storyId}`);
              currentStoryId = storyId;

              // Update UI elements immediately for feedback
              characterReferenceArea.innerHTML = '<p>Loading characters...</p>';
              modelResultsArea.innerHTML = '<p>Loading results...</p>';
              shotIndicatorText.textContent = 'Shot [?] of [?]';
              prevShotBtn.disabled = true;
              nextShotBtn.disabled = true;

              // Update Story Title (use placeholder from translations)
              const titleKey = 'story_detail_title';
              const currentLang = document.documentElement.lang || 'en';
              let titleText = translations[currentLang]?.[titleKey] || translations.en[titleKey];
              // Find story name from manifest for replacement
              const storyInfo = availableStories.find(s => s.id === storyId);
              titleText = titleText.replace('[Story ID]', storyInfo ? storyInfo.name : storyId);
              storyTitleElement.textContent = titleText;

              // Deactivate other story tabs, activate current one
              storyWallContainer.querySelectorAll('.story-card').forEach(card => {
                  card.classList.remove('active');
                  if (card.getAttribute('data-story-id') === storyId) {
                      card.classList.add('active');
                  }
              });

              // Fetch the data
              currentStoryData = await fetchStoryData(storyId);

              if (currentStoryData && currentStoryData.Shots) {
                  totalShots = currentStoryData.Shots.length;
                  currentShotIndex = 0; // Reset to first shot

                  // Populate UI sections
                  populateModelContainers(); // Create model containers and dropdowns, which triggers initial image load
              } else {
                  totalShots = 0;
                  currentShotIndex = 0;
                  // Error messages are set within fetchStoryData
                  shotIndicatorText.textContent = 'Shot [0] of [0]';
              }
              // Now update elements specific to this page that depend on language and loaded data
            if (currentStoryData) {
                 const storyInfo = availableStories.find(s => s.id === currentStoryId);
                 const titleKey = 'story_detail_title';
                 let titleText = translations[currentLang]?.[titleKey] || translations.en[titleKey];
                 titleText = titleText.replace('[Story ID]', storyInfo ? storyInfo.name : currentStoryId); // Update title lang
                 storyTitleElement.textContent = titleText;

                 updateCharacterReferences(); // Update character names/refs
                 if (currentShotIndex >= 0 && currentShotIndex < totalShots) {
                     updateExplorerView(currentShotIndex); // Update script, indicator, char highlighting
                 }
            }
          }


        // --- Event Handlers ---
        function changeShot(direction) {
             if (totalShots <= 0) return; // Do nothing if no shots
            let newIndex = currentShotIndex + direction;
            if (newIndex < 0) {
                newIndex = totalShots - 1; // Wrap around
            } else if (newIndex >= totalShots) {
                newIndex = 0; // Wrap around
            }
            updateExplorerView(newIndex);
        }

         function handleImageClick(event) {
             if (event.target.classList.contains('sequence-image')) {
                  const clickedShotIndex = parseInt(event.target.dataset.shotIndex);
                  if (!isNaN(clickedShotIndex) && clickedShotIndex !== currentShotIndex) {
                      updateExplorerView(clickedShotIndex);
                 }
            }
        }

         // --- Autoplay Timer & Progress ---
         function startProgressBar() {
             let progress = 0;
             clearInterval(progressInterval);
             progressBar.style.width = '0%'; // Reset visually

             // Only start if there are shots
             if (totalShots > 0) {
             progressInterval = setInterval(() => {
                     progress += 100 / (autoPlayInterval / 100); // Calculate progress increment
                 if (progress <= 100) {
                     progressBar.style.width = progress + '%';
                 } else {
                     clearInterval(progressInterval);
                          // Timer elapsed, but we let the setTimeout handle the changeShot
                 }
             }, 100); // Update every 100ms
             }
         }

         function resetAutoPlayTimer() {
             clearTimeout(autoPlayTimer);
             clearInterval(progressInterval); // Stop current progress animation
             progressBar.style.width = '0%'; // Reset progress bar visually

             // Only restart if there are shots
             if (totalShots > 0) {
             startProgressBar(); // Start new progress animation
             autoPlayTimer = setTimeout(() => {
                      changeShot(1); // Autoplay IS enabled
             }, autoPlayInterval);
             }
         }

        // --- Language Change Integration ---
        // Override or augment the global changeLanguage function if needed for this specific page
        const originalChangeLanguage = window.changeLanguage;
        window.changeLanguage = function(lang) {
            originalChangeLanguage(lang); // Call the original function first

            // Now update elements specific to this page that depend on language and loaded data
            
        };

        // --- Initial Load ---
        function initializeExplorer() {
             console.log("Initializing Result Explorer...");

             // Add event listeners for pagination buttons
             if(prevPageBtn) prevPageBtn.addEventListener('click', () => changeStoryPage(-1));
             if(nextPageBtn) nextPageBtn.addEventListener('click', () => changeStoryPage(1));
 
             // Fetch the detailed manifest first
             fetch(`${DATA_BASE_PATH}/detailed_manifest.json`)
                 .then(response => {
                     if (!response.ok) {
                         throw new Error(`HTTP error! status: ${response.status} - Check if detailed_manifest.json exists and is valid.`);
                     }
                     return response.json();
                 })
                 .then(data => {
                     detailedManifest = data;
                     availableStories = detailedManifest.stories || []; // Update available stories
                     console.log("Detailed manifest loaded:", detailedManifest);

                     populateStorySelector(); // Now populate stories based on manifest

                     // Attempt to load story from URL parameter or default
                     const urlParams = new URLSearchParams(window.location.search);
                     const storyIdFromUrl = urlParams.get('story');

                     let storyToLoad = null;
                     if (storyIdFromUrl && availableStories.some(s => s.id === storyIdFromUrl)) {
                         storyToLoad = storyIdFromUrl;
                         // If loading a specific story, try to find its page for initial display
                         const storyIndex = availableStories.findIndex(s => s.id === storyIdFromUrl);
                         if (storyIndex !== -1) {
                             currentPage = Math.floor(storyIndex / storiesPerPage) + 1;
                         }
                         populateStorySelector(); // Populate story wall first
                         loadStory(storyToLoad);
                     } else if (availableStories.length > 0) {
                         storyToLoad = availableStories[0].id; // Load the first story by default
                         currentPage = 1; // Start at page 1
                         populateStorySelector(); // Populate story wall first
                         loadStory(storyToLoad);
                     } else {
                         storyWallContainer.innerHTML = '<p>No stories found in manifest.</p>';
                         document.getElementById('story-pagination-controls').style.display = 'none';
                         modelResultsArea.innerHTML = '<p>No stories available.</p>';
                         console.error("No stories available to load from manifest.");
                     }
                 })
                 .catch(error => {
                      console.error("Error fetching or parsing detailed_manifest.json:", error);
                      storyTabsContainer.innerHTML = `<p>Error loading story list. Check manifest: ${error.message}</p>`;
                      modelResultsArea.innerHTML = '<p>Error loading configuration.</p>';
                 });
        }

        document.addEventListener('DOMContentLoaded', initializeExplorer);

    </script>
</body>
</html> 