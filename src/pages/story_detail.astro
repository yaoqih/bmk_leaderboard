---
import BaseLayout from '../layouts/BaseLayout.astro';
import { translations } from '../../public/js/translations.js'; // Assuming translations.js exports this

const pageSpecificTitle = "Result Explorer"; // Will be dynamically updated by JS
const currentNav = "explorer"; // Or whatever matches your nav keys

// Placeholder for initial title until JS updates it, using a common key
const initialTitleLangKey = "story_detail_title"; 
// Assuming 'en' is a safe default if Astro cannot determine lang at build time for this.
// The client-side JS will handle actual language-based title updates.
const initialTitleText = translations['en']?.[initialTitleLangKey]?.replace('[Story ID]', '') || "Result Explorer";
---
<BaseLayout title={initialTitleText} activeNav={currentNav}>
  <div class="container mx-auto px-4 py-8">
    <!-- Story Selector Section -->
    <section id="story-selector-section" class="mb-8 p-6 bg-white shadow-lg rounded-lg">
      <h3 class="text-2xl font-semibold text-gray-700 mb-4" data-lang-key="select_story_title">Select Story:</h3>
      <div id="story-wall-container" class="flex flex-wrap gap-5 justify-center p-2.5 min-h-[250px] bg-gray-50 rounded">
        <!-- JS will populate this with story cards -->
        <p class="text-gray-500">Loading stories...</p>
      </div>
      <div id="story-pagination-controls" class="flex justify-center items-center mt-5 gap-2.5">
        <button id="prev-page-btn" data-lang-key="prev_page" class="py-2 px-4 cursor-pointer border border-gray-300 bg-gray-100 hover:bg-gray-200 rounded disabled:opacity-50 disabled:cursor-not-allowed">Previous</button>
        <span id="page-info" class="text-sm text-gray-600">Page X of Y</span>
        <button id="next-page-btn" data-lang-key="next_page" class="py-2 px-4 cursor-pointer border border-gray-300 bg-gray-100 hover:bg-gray-200 rounded disabled:opacity-50 disabled:cursor-not-allowed">Next</button>
      </div>
    </section>

    <!-- Input Information Section -->
    <section id="input-info" class="mb-8 p-6 bg-white shadow-lg rounded-lg grid md:grid-cols-2 gap-8">
      <div>
        <h3 class="text-xl font-semibold text-gray-700 mb-3" data-lang-key="input_script">Input Script</h3>
        <div id="script-details-area" class="space-y-3 text-sm text-gray-600">
          <div>
            <h4 class="font-semibold text-gray-700" data-lang-key="script_plot">Plot Correspondence</h4>
            <p id="script-plot-display">[Select a story to load script]</p>
          </div>
          <div>
            <h4 class="font-semibold text-gray-700" data-lang-key="script_setting">Setting Description</h4>
            <p id="script-setting-display">-</p>
          </div>
          <div>
            <h4 class="font-semibold text-gray-700" data-lang-key="script_perspective">Shot Perspective Design</h4>
            <p id="script-perspective-display">-</p>
          </div>
          <div>
            <h4 class="font-semibold text-gray-700" data-lang-key="script_static_desc">Static Shot Description</h4>
            <p id="script-static-desc-display">-</p>
          </div>
        </div>
        <p class="mt-4"><strong id="shot-indicator-text" data-lang-key="shot_current_of_total" class="text-gray-700">Shot [?] of [?]</strong></p>
      </div>
      <div>
        <h3 class="text-xl font-semibold text-gray-700 mb-3" data-lang-key="character_ref">Character Reference</h3>
        <div class="character-refs" id="character-reference-area">
          <!-- JS will populate this -->
          <p class="text-gray-500">Select a story to load characters.</p>
        </div>
      </div>
    </section>

    <!-- Global Controls -->
    <section class="global-controls mb-8 p-4 bg-gray-100 shadow-md rounded-lg flex justify-between items-center gap-4">
      <button id="prev-shot-btn" data-lang-key="prev_shot" disabled class="py-2 px-4 cursor-pointer bg-gray-600 hover:bg-sky-600 text-white border-none rounded-md transition-colors disabled:opacity-50 disabled:cursor-not-allowed">Previous Shot</button>
      <div class="carousel-timer w-3/5 h-2.5 bg-gray-300 rounded-full overflow-hidden">
        <div class="carousel-progress h-full bg-sky-500 transition-all duration-100 ease-linear" id="carousel-progress-bar" style="width: 0%;"></div>
      </div>
      <button id="next-shot-btn" data-lang-key="next_shot" disabled class="py-2 px-4 cursor-pointer bg-gray-600 hover:bg-sky-600 text-white border-none rounded-md transition-colors disabled:opacity-50 disabled:cursor-not-allowed">Next Shot</button>
    </section>

    <!-- Vertically Stacked Model Sequences -->
    <section id="model-results-area" class="space-y-8">
      <!-- JS will populate this area based on selected story and models -->
      <p class="text-gray-500 p-6 bg-white shadow-lg rounded-lg">Select a story to view results.</p>
      <!-- Example Structure (Generated by JS, Tailwind classes will be applied by JS) -->
      
      <!-- <div class="model-sequence-container" data-model-key="storygen">
        <h4>StoryGen</h4>
        <div class="model-config">
          ...
        </div>
        <div class="image-sequence-scroll-container">
          <p>Loading images...</p>
        </div>
      </div> -->
     
    </section>
  </div>
</BaseLayout>

<script define:vars={{ initialTranslations: translations }}>
// --- Result Explorer Specific JS ---

// --- Configuration & State ---
const DATA_BASE_PATH = '/data'; // Astro public directory mapping
let currentStoryData = null;
let currentStoryId = null;
let currentDataset = null;
let availableStories = [];
let detailedManifest = null;
let currentShotIndex = 0;
let totalShots = 0;
let autoPlayTimer = null;
const autoPlayInterval = 5000;
let progressInterval = null;

// Pagination State
let currentPage = 1;
const storiesPerPage = 8; // Adjusted for potentially wider cards with Tailwind
let totalStoryPages = 0;

// --- DOM References ---
const storyWallContainer = document.getElementById('story-wall-container');
const prevPageBtn = document.getElementById('prev-page-btn');
const nextPageBtn = document.getElementById('next-page-btn');
const pageInfoDisplay = document.getElementById('page-info');

// storyTitleElement is part of BaseLayout, might need different handling or ensure BaseLayout exposes it or a method to update.
// For now, let's assume direct manipulation if ID is consistent, or pass via props if BaseLayout allows.
// We will use the 'astro.props.title' for initial, and JS will update document.title and a specific H1 if needed.
// The H1 for story detail title is not in the provided BaseLayout snippet, let's assume it's this one:
const storyTitleElement = document.querySelector('h1#story-detail-main-title') || document.querySelector('h1'); // Fallback, ideally specific
const shotIndicatorText = document.getElementById('shot-indicator-text');
const progressBar = document.getElementById('carousel-progress-bar');
const characterReferenceArea = document.getElementById('character-reference-area');
const modelResultsArea = document.getElementById('model-results-area');
const prevShotBtn = document.getElementById('prev-shot-btn');
const nextShotBtn = document.getElementById('next-shot-btn');


// --- Data Fetching ---
async function fetchStoryData(storyId) {
  if (!detailedManifest || !detailedManifest.stories) {
    console.error("Detailed manifest not loaded yet.");
    return null;
  }
  const storyInfo = detailedManifest.stories.find(s => s.id === storyId);
  if (!storyInfo) {
    console.error(`Story info not found for ID: ${storyId}`);
    return null;
  }
  currentDataset = storyInfo.dataset_base;
  const storyJsonPath = `${DATA_BASE_PATH}/datasets/${currentDataset}/${storyInfo.id}/story.json`;
  console.log(`Fetching story data from: ${storyJsonPath}`);
  try {
    const response = await fetch(storyJsonPath);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return await response.json();
  } catch (error) {
    console.error("Error fetching story data:", error);
    if(characterReferenceArea) characterReferenceArea.innerHTML = `<p class="text-red-500">Error loading character data.</p>`;
    if(modelResultsArea) modelResultsArea.innerHTML = `<p class="text-red-500">Error loading results.</p>`;
    return null;
  }
}

// --- UI Update Functions ---
function populateStorySelector() {
  if (!storyWallContainer) return;
  storyWallContainer.innerHTML = ''; 

  if (!availableStories || availableStories.length === 0) {
    storyWallContainer.innerHTML = '<p class="text-gray-500">No stories found in manifest.</p>';
    const paginationControls = document.getElementById('story-pagination-controls');
    if (paginationControls) paginationControls.style.display = 'none';
    return;
  }
  const paginationControls = document.getElementById('story-pagination-controls');
  if (paginationControls) paginationControls.style.display = 'flex';

  totalStoryPages = Math.ceil(availableStories.length / storiesPerPage);
  const startIndex = (currentPage - 1) * storiesPerPage;
  const endIndex = startIndex + storiesPerPage;
  const storiesToDisplay = availableStories.slice(startIndex, endIndex);

  if (storiesToDisplay.length === 0 && currentPage > 1) {
    currentPage--;
    populateStorySelector();
    return;
  }

  storiesToDisplay.forEach(story => {
    const card = document.createElement('div');
    // Tailwind classes for story-card
    card.className = 'w-[150px] md:w-[180px] border border-gray-300 rounded-lg p-2.5 text-center cursor-pointer transition-all duration-300 ease-in-out bg-white flex flex-col items-center shadow-md hover:shadow-xl hover:-translate-y-1';
    if (story.id === currentStoryId) {
        card.classList.add('border-sky-500', 'shadow-lg', 'shadow-sky-500/50', 'transform-none');
    }
    card.setAttribute('data-story-id', story.id);
    card.onclick = () => loadStory(story.id);

    const img = document.createElement('img');
    // Tailwind classes for story-card img
    img.className = 'w-full h-[180px] md:h-[220px] object-cover rounded mb-2 bg-gray-100';
    img.src = story.cover_image_path 
        ? (story.cover_image_path.startsWith('/') ? story.cover_image_path : `/${story.cover_image_path}`) 
        : '/img/placeholder_story_cover.png';
    img.alt = story.name;
    img.onerror = () => { img.src = '/img/placeholder_story_cover.png'; };

    const name = document.createElement('p');
    // Tailwind classes for story-card .story-name
    name.className = 'text-sm font-semibold text-gray-700 mt-auto';
    name.textContent = `${story.story_type_en || story.story_type || ''} (${story.name})`.trim();


    card.appendChild(img);
    card.appendChild(name);
    storyWallContainer.appendChild(card);
  });

  updatePaginationControls();
}

function updatePaginationControls() {
  if (!pageInfoDisplay || !prevPageBtn || !nextPageBtn) return;
  const paginationControls = document.getElementById('story-pagination-controls');

  if (totalStoryPages <= 0) {
    if(paginationControls) paginationControls.style.display = 'none';
    return;
  }
  if(paginationControls) paginationControls.style.display = 'flex';
  
  pageInfoDisplay.textContent = `Page ${currentPage} of ${totalStoryPages}`;
  prevPageBtn.disabled = currentPage === 1;
  nextPageBtn.disabled = currentPage === totalStoryPages || totalStoryPages === 0;
}

function changeStoryPage(direction) {
  currentPage += direction;
  if (currentPage < 1) currentPage = 1;
  if (currentPage > totalStoryPages) currentPage = totalStoryPages;
  populateStorySelector();
}

function updateCharacterReferences() {
  if (!characterReferenceArea) return;
  characterReferenceArea.innerHTML = '';
  if (!currentStoryData || !currentStoryData.Characters) {
    characterReferenceArea.innerHTML = '<p class="text-gray-500">No character data found.</p>';
    return;
  }
  const currentLang = document.documentElement.lang || 'en';

  Object.entries(currentStoryData.Characters).forEach(([charKey, charData]) => {
    const charDiv = document.createElement('div');
    charDiv.className = 'mb-2'; // Spacing for each character block
    const charName = charData[`name_${currentLang}`] || charData.name_en || charKey;
    charDiv.setAttribute('data-char-key', charKey);
    
    const nameEl = document.createElement('strong');
    nameEl.className = 'text-gray-700';
    nameEl.textContent = `${charName}: `;
    charDiv.appendChild(nameEl);

    const imageBasePath = `${DATA_BASE_PATH}/datasets/${currentDataset}/${currentStoryId}/image/${charKey}/`;

    if (charData.ref_images && Array.isArray(charData.ref_images) && charData.ref_images.length > 0) {
      charData.ref_images.forEach((imageFilename, index) => {
        const imgSrc = `${imageBasePath}${imageFilename}`;
        const img = document.createElement('img');
        // Tailwind classes for character-refs img
        img.className = 'max-w-[60px] md:max-w-[80px] m-1 border border-gray-300 rounded align-middle inline-block';
        img.src = imgSrc;
        img.alt = `${charName} Ref ${index + 1}`;
        img.setAttribute('data-char-key', charKey);
        img.onerror = () => { img.style.display = 'none'; };
        charDiv.appendChild(img);
      });
    } else {
      charDiv.appendChild(document.createTextNode(' [No reference images listed]'));
    }

    if (charDiv.querySelectorAll('img:not([style*="display: none"])').length === 0 && charData.ref_images && charData.ref_images.length > 0) {
      charDiv.appendChild(document.createTextNode(' [Images failed to load]'));
    }
    characterReferenceArea.appendChild(charDiv);
  });
}

async function populateModelContainers() {
  if (!modelResultsArea) return;
  modelResultsArea.innerHTML = '';
  if (!currentStoryData || !detailedManifest || !detailedManifest.outputs || !currentStoryId) {
    modelResultsArea.innerHTML = '<p class="text-red-500 p-6 bg-white shadow-lg rounded-lg">Cannot display models: Story data or manifest missing/invalid.</p>';
    console.error("Missing data for populateModelContainers", currentStoryData, detailedManifest, currentStoryId);
    return;
  }

  const storyInfo = detailedManifest.stories.find(s => s.id === currentStoryId);
  if (!storyInfo) {
    modelResultsArea.innerHTML = `<p class="text-red-500 p-6 bg-white shadow-lg rounded-lg">Internal error: Could not find story info for ID '${currentStoryId}' in manifest.</p>`;
    console.error("Could not find story info for ID:", currentStoryId, "in manifest stories:", detailedManifest.stories);
    return;
  }

  const currentLang = document.documentElement.lang || 'en';

  Object.keys(detailedManifest.outputs).forEach(modelKey => {
    const modelData = detailedManifest.outputs[modelKey];

    const modelContainer = document.createElement('div');
    // Tailwind for model-sequence-container, ensure 'model-sequence-container' class is present
    modelContainer.className = 'model-sequence-container p-6 bg-white shadow-lg rounded-lg'; 
    modelContainer.setAttribute('data-model-key', modelKey);

    const title = document.createElement('h4');
    // Tailwind for model-sequence-container h4
    title.className = 'text-xl font-semibold text-gray-700 mb-4 text-center';
    const modelNameKey = `model_${modelKey}`;
    const modelName = initialTranslations[currentLang]?.[modelNameKey] || initialTranslations.en?.[modelNameKey] || modelKey;
    title.textContent = modelName;
    modelContainer.appendChild(title);

    const configDiv = document.createElement('div');
    // Tailwind for model-config
    configDiv.className = 'flex flex-wrap gap-4 mb-4 items-center p-3 bg-gray-50 rounded-md border border-gray-200';

    const modes = Object.keys(modelData);
    const modeSelectContainer = createDropdown(modelKey, 'mode', 'Mode', modes);
    configDiv.appendChild(modeSelectContainer);
    const langs = Object.keys(modelData[modes[0]]['WildStory']);
    const langSelectContainer = createDropdown(modelKey, 'lang', 'Language', langs);
    configDiv.appendChild(langSelectContainer);
    const timestamps = modelData[modes[0]]['WildStory'][langs[0]][currentStoryId];
    const tsSelectContainer = createDropdown(modelKey, 'ts', 'Timestamp', timestamps);
    configDiv.appendChild(tsSelectContainer);

    modelContainer.appendChild(configDiv);

    const scrollContainer = document.createElement('div');
    // Tailwind for image-sequence-scroll-container
    scrollContainer.className = 'image-sequence-scroll-container flex overflow-x-auto overflow-y-hidden gap-2.5 pb-4 whitespace-nowrap items-center min-h-[150px] bg-gray-100 border border-gray-200 rounded p-2';
    scrollContainer.innerHTML = '<p class="text-gray-500">Select configuration to load images.</p>';
    modelContainer.appendChild(scrollContainer);

    modelResultsArea.appendChild(modelContainer);
    updateDependentDropdowns(modelKey);
  });

  if (currentShotIndex >= 0 && currentShotIndex < totalShots) {
    updateExplorerView(currentShotIndex);
  }
}

function createDropdown(modelKey, type, labelTextKey, options) {
  const currentUiLang = document.documentElement.lang || 'en';
  let labelText = initialTranslations[currentUiLang]?.[labelTextKey] || labelTextKey; // Fallback to key itself
  if (!labelText) labelText = type.charAt(0).toUpperCase() + type.slice(1); // Default label from type

  const div = document.createElement('div');
  div.className = 'flex items-center'; // Tailwind for layout

  const label = document.createElement('label');
  // Tailwind for model-config label
  label.className = 'font-medium text-sm text-gray-700 mr-2';
  label.setAttribute('for', `${type}-select-${modelKey}`);
  label.textContent = `${labelText}:`;

  const select = document.createElement('select');
  select.id = `${type}-select-${modelKey}`;
  // Tailwind for model-config select
  select.className = 'py-1.5 px-2 border border-gray-300 rounded-md shadow-sm text-sm focus:ring-sky-500 focus:border-sky-500';
  select.setAttribute('data-model-key', modelKey);
  select.onchange = () => handleConfigChange(modelKey, type);

  options.forEach(optionValue => {
    const option = document.createElement('option');
    option.value = optionValue;
    option.textContent = optionValue;
    select.appendChild(option);
  });

  div.appendChild(label);
  div.appendChild(select);
  return div;
}

function handleConfigChange(modelKey, changedType) {
  console.log(`Config changed for ${modelKey}: ${changedType}`);
  updateDependentDropdowns(modelKey);
}

function updateDependentDropdowns(modelKey) {
  const modelContainer = modelResultsArea.querySelector(`.model-sequence-container[data-model-key="${modelKey}"]`);
  if (!modelContainer || !detailedManifest) return;

  const modeSelect = modelContainer.querySelector(`#mode-select-${modelKey}`);
  const langSelect = modelContainer.querySelector(`#lang-select-${modelKey}`);
  const tsSelect = modelContainer.querySelector(`#ts-select-${modelKey}`);
  const storyInfo = detailedManifest.stories.find(s => s.id === currentStoryId);

  if (!modeSelect || !langSelect || !tsSelect || !storyInfo) return;

  const selectedMode = modeSelect.value;
  const datasetBase = storyInfo.dataset_base;
  const storyId = storyInfo.id;

  const availableLangs = detailedManifest.outputs[modelKey]?.[selectedMode]?.[datasetBase]
    ? Object.keys(detailedManifest.outputs[modelKey][selectedMode][datasetBase])
    : [];

  const currentLangVal = langSelect.value;
  langSelect.innerHTML = '';
  availableLangs.forEach(lang => {
    if (detailedManifest.outputs[modelKey]?.[selectedMode]?.[datasetBase]?.[lang]?.[storyId]?.length > 0) {
      const option = document.createElement('option');
      option.value = lang;
      option.textContent = lang;
      langSelect.appendChild(option);
    }
  });
  if (availableLangs.includes(currentLangVal) && langSelect.querySelector(`option[value="${currentLangVal}"]`)) {
    langSelect.value = currentLangVal;
  } else if (langSelect.options.length > 0) {
    langSelect.selectedIndex = 0;
  }

  updateTimestampDropdown(modelKey);
}

function updateTimestampDropdown(modelKey) {
  const modelContainer = modelResultsArea.querySelector(`.model-sequence-container[data-model-key="${modelKey}"]`);
  if (!modelContainer || !detailedManifest) return;

  const modeSelect = modelContainer.querySelector(`#mode-select-${modelKey}`);
  const langSelect = modelContainer.querySelector(`#lang-select-${modelKey}`);
  const tsSelect = modelContainer.querySelector(`#ts-select-${modelKey}`);
  const storyInfo = detailedManifest.stories.find(s => s.id === currentStoryId);

  if (!modeSelect || !langSelect || !tsSelect || !storyInfo || !langSelect.value) { // Check langSelect.value
     if(tsSelect) tsSelect.innerHTML = ''; // Clear timestamp if no language selected
     loadModelSequence(modelKey); // Attempt to load (will likely show "incomplete config")
     return;
  }


  const selectedMode = modeSelect.value;
  const selectedLang = langSelect.value;
  const datasetBase = storyInfo.dataset_base;
  const storyId = storyInfo.id;

  const availableTimestamps = detailedManifest.outputs[modelKey]?.[selectedMode]?.[datasetBase]?.[selectedLang]?.[storyId] || [];

  const currentTsVal = tsSelect.value;
  tsSelect.innerHTML = '';
  availableTimestamps.forEach(ts => {
    const option = document.createElement('option');
    option.value = ts;
    option.textContent = ts;
    tsSelect.appendChild(option);
  });
  if (availableTimestamps.includes(currentTsVal)) {
    tsSelect.value = currentTsVal;
  } else if (tsSelect.options.length > 0) {
    tsSelect.selectedIndex = 0;
  }
  loadModelSequence(modelKey);
}

function loadModelSequence(modelKey) {
  const modelContainer = modelResultsArea.querySelector(`.model-sequence-container[data-model-key="${modelKey}"]`);
  if(!modelContainer) return;
  const modeSelect = modelContainer.querySelector(`#mode-select-${modelKey}`);
  const langSelect = modelContainer.querySelector(`#lang-select-${modelKey}`);
  const tsSelect = modelContainer.querySelector(`#ts-select-${modelKey}`);
  const scrollContainer = modelContainer.querySelector('.image-sequence-scroll-container'); // Tailwind class
  const storyInfo = detailedManifest.stories.find(s => s.id === currentStoryId);

  if (!modeSelect || !langSelect || !tsSelect || !scrollContainer || !storyInfo || !modeSelect.value || !langSelect.value || !tsSelect.value) {
    console.warn(`Cannot load sequence for ${modelKey}: Missing config or elements.`);
    if(scrollContainer) scrollContainer.innerHTML = '<p class="text-gray-500 p-2">Incomplete configuration.</p>';
    return;
  }

  scrollContainer.innerHTML = '<p class="text-gray-500 p-2">Loading images...</p>';

  const selectedMode = modeSelect.value;
  const selectedLang = langSelect.value;
  const selectedTimestamp = tsSelect.value;
  const datasetBase = storyInfo.dataset_base;
  const fullDatasetName = `${datasetBase}_${selectedLang}`;

  if (!currentStoryData.Shots || currentStoryData.Shots.length === 0) {
    scrollContainer.innerHTML = '<p class="text-gray-500 p-2">No shots defined for this story.</p>';
    return;
  }

  scrollContainer.innerHTML = '';

  const currentUiLang = document.documentElement.lang || 'en';
  const modelNameKey = `model_${modelKey}`;
  const modelName = initialTranslations[currentUiLang]?.[modelNameKey] || initialTranslations.en?.[modelNameKey] || modelKey;


  currentStoryData.Shots.forEach((shot, index) => {
    const img = document.createElement('img');
    const shotIndexStr = shot.index.toString().padStart(2, '0');
    const imagePath = `${DATA_BASE_PATH}/outputs/${modelKey}/${selectedMode}/${fullDatasetName}/${currentStoryId}/${selectedTimestamp}/shot_${shotIndexStr}.png`;

    // Tailwind for image-sequence-scroll-container img
    img.className = 'max-h-[180px] md:max-h-[200px] w-auto inline-block border-2 border-transparent cursor-pointer transition-all duration-300 rounded shadow-sm hover:shadow-md';
    img.src = imagePath;
    img.alt = `Model ${modelName} - Shot ${shot.index}`;
    img.classList.add('sequence-image');
    img.setAttribute('data-shot-index', index);
    img.setAttribute('data-shot-id', shot.index);
    img.addEventListener('click', handleImageClick);
    img.onerror = () => {
      console.warn("Error loading image:", imagePath);
      img.alt = `Error loading ${modelName} - Shot ${shot.index}`;
      img.src = '/img/placeholder_error.png'; // Ensure this placeholder exists
      img.classList.add('border-red-300');
    };
    scrollContainer.appendChild(img);
  });
  updateFocusInContainer(modelContainer, currentShotIndex);
}

function updateFocusInContainer(container, shotIndex) {
  if (!container) return;
  let foundFocused = false;
  container.querySelectorAll('.sequence-image').forEach(img => {
    if (parseInt(img.dataset.shotIndex) === shotIndex) {
      // Tailwind for .focused img
      img.classList.add('border-sky-500', 'transform', 'scale-105', 'shadow-lg', 'shadow-sky-500/30');
      requestAnimationFrame(() => {
        const scrollContainer = container.querySelector('.image-sequence-scroll-container'); // Tailwind class
        if (scrollContainer && img) {
            const containerRect = scrollContainer.getBoundingClientRect();
            const imgRect = img.getBoundingClientRect();
            const desiredImgLeftInContainer = (containerRect.width - imgRect.width) / 2;
            const currentImgLeftInContainer = imgRect.left - containerRect.left;
            const scrollAmount = currentImgLeftInContainer - desiredImgLeftInContainer;
            scrollContainer.scrollTo({
                left: scrollContainer.scrollLeft + scrollAmount,
                behavior: 'smooth'
            });
        }
      });
      foundFocused = true;
    } else {
      img.classList.remove('border-sky-500', 'transform', 'scale-105', 'shadow-lg', 'shadow-sky-500/30');
    }
  });
   if (!foundFocused && currentStoryData?.Shots?.length > 0) { // only warn if shots were expected
     console.warn(`Focused image for shot index ${shotIndex} not found in model ${container.dataset.modelKey}`);
   }
}

        function updateExplorerView(shotIndex) {
  if (!currentStoryData || !currentStoryData.Shots || shotIndex < 0 || shotIndex >= totalShots) {
    console.warn("updateExplorerView: Aborting - Invalid shotIndex or no story data.", shotIndex, currentStoryData);
                return;
            }
            currentShotIndex = shotIndex;
            const shot = currentStoryData.Shots[currentShotIndex];
            const currentUiLang = document.documentElement.lang || 'en';

  const plotDisplay = document.getElementById('script-plot-display');
  const settingDisplay = document.getElementById('script-setting-display');
  const perspectiveDisplay = document.getElementById('script-perspective-display');
  const staticDescDisplay = document.getElementById('script-static-desc-display');

  if(plotDisplay) plotDisplay.textContent = shot['Plot Correspondence']?.[currentUiLang] || shot['Plot Correspondence']?.['en'] || "-";
  if(settingDisplay) settingDisplay.textContent = shot['Setting Description']?.[currentUiLang] || shot['Setting Description']?.['en'] || "-";
  if(perspectiveDisplay) perspectiveDisplay.textContent = shot['Shot Perspective Design']?.[currentUiLang] || shot['Shot Perspective Design']?.['en'] || "-";
  if(staticDescDisplay) staticDescDisplay.textContent = shot['Static Shot Description']?.[currentUiLang] || shot['Static Shot Description']?.['en'] || "-";

            const indicatorTextKey = 'shot_current_of_total';
  let indicatorText = initialTranslations[currentUiLang]?.[indicatorTextKey] || initialTranslations.en[indicatorTextKey];
  indicatorText = indicatorText.replace('[Current Shot]', shot.index.toString()).replace('[Total Shots]', totalShots.toString());
            if(shotIndicatorText) shotIndicatorText.textContent = indicatorText;

            if(characterReferenceArea) {
    characterReferenceArea.querySelectorAll('img').forEach(img => img.classList.remove('border-sky-500', 'shadow-md', 'shadow-sky-500/50', 'transform', 'scale-105')); // Tailwind relevant-char + scale
                const charactersInShot = shot['Characters Appearing']?.[currentUiLang] || shot['Characters Appearing']?.['en'] || [];
    if (charactersInShot.length > 0) {
                    const charKeyMap = {};
                    Object.entries(currentStoryData.Characters).forEach(([key, charData]) => {
        charKeyMap[charData.name_en] = key;
        if (charData.name_ch) charKeyMap[charData.name_ch] = key;
      });
      charactersInShot.forEach(charName => {
        const charKey = charKeyMap[charName];
                        if (charKey) {
                            characterReferenceArea.querySelectorAll(`img[data-char-key="${charKey}"]`).forEach(img => {
            if (img.offsetParent !== null) {
              img.classList.add('border-sky-500', 'shadow-md', 'shadow-sky-500/50', 'transform', 'scale-105'); // Tailwind relevant-char + scale
                                }
                            });
                        } else {
          console.warn(`Could not find key for character name: ${charName}`);
        }
                    });
                }
            }
            
                modelResultsArea.querySelectorAll('.model-sequence-container').forEach(container => {
                    if (container.style.display !== 'none') { 
      updateFocusInContainer(container, currentShotIndex);
    }
  });

  resetAutoPlayTimer();
  if(prevShotBtn) prevShotBtn.disabled = (totalShots <= 0); // Enable/disable shot buttons
  if(nextShotBtn) nextShotBtn.disabled = (totalShots <= 0);
}

async function loadStory(storyId) {
  console.log(`Loading story: ${storyId}`);
  currentStoryId = storyId;

  if(characterReferenceArea) characterReferenceArea.innerHTML = '<p class="text-gray-500">Loading characters...</p>';
  if(modelResultsArea) modelResultsArea.innerHTML = '<p class="text-gray-500 p-6 bg-white shadow-lg rounded-lg">Loading results...</p>';
  if(shotIndicatorText) shotIndicatorText.textContent = 'Shot [?] of [?]';
  if(prevShotBtn) prevShotBtn.disabled = true;
  if(nextShotBtn) nextShotBtn.disabled = true;

  const currentUiLang = document.documentElement.lang || 'en';
  const titleKey = 'story_detail_title';
  let titleText = initialTranslations[currentUiLang]?.[titleKey] || initialTranslations.en[titleKey] || "Result Explorer";

  const storyInfoForTitle = availableStories.find(s => s.id === storyId);
  titleText = titleText.replace('[Story ID]', storyInfoForTitle ? storyInfoForTitle.name : storyId);
  
  // Update document title and H1 if available
  document.title = titleText;
  const mainPageTitleElement = document.getElementById('story-detail-main-title'); // Assuming BaseLayout provides this ID for main H1
  if (mainPageTitleElement) {
    mainPageTitleElement.textContent = titleText;
  } else if (storyTitleElement && storyTitleElement.tagName === 'H1') { // Fallback to first H1
    storyTitleElement.textContent = titleText;
  }


  if(storyWallContainer) {
    storyWallContainer.querySelectorAll('.story-card').forEach(card => { // Tailwind class for story card
      card.classList.remove('border-sky-500', 'shadow-lg', 'shadow-sky-500/50', 'transform-none');
      if (card.getAttribute('data-story-id') === storyId) {
        card.classList.add('border-sky-500', 'shadow-lg', 'shadow-sky-500/50', 'transform-none');
                    }
                });
            }

  currentStoryData = await fetchStoryData(storyId);

  if (currentStoryData && currentStoryData.Shots) {
    totalShots = currentStoryData.Shots.length;
    currentShotIndex = 0;
    await populateModelContainers(); // This is async due to its own logic that might await
  } else {
    totalShots = 0;
    currentShotIndex = 0;
    if(shotIndicatorText) shotIndicatorText.textContent = 'Shot [0] of [0]';
     if(modelResultsArea) modelResultsArea.innerHTML = `<p class="text-red-500 p-6 bg-white shadow-lg rounded-lg">Failed to load story data or story has no shots.</p>`;
  }
  
  // This part was in original changeLanguage override, better here post-load.
  if (currentStoryData) {
      const storyInfo = availableStories.find(s => s.id === currentStoryId);
      const titleKey = 'story_detail_title';
      const currentLang = document.documentElement.lang || 'en';
      let newTitleText = initialTranslations[currentLang]?.[titleKey] || initialTranslations.en[titleKey];
      newTitleText = newTitleText.replace('[Story ID]', storyInfo ? storyInfo.name : currentStoryId);
      // Update title element specifically for this page if exists
      if (storyTitleElement) storyTitleElement.textContent = newTitleText;
      document.title = newTitleText; // Also update document title

      updateCharacterReferences();
      if (totalShots > 0 && currentShotIndex >= 0 && currentShotIndex < totalShots) { // Ensure currentShotIndex is valid
           updateExplorerView(currentShotIndex);
      } else if (totalShots === 0) { // If no shots, clear view or show message
          // Potentially clear script details or show "no shots" message
          const plotDisplay = document.getElementById('script-plot-display');
          if(plotDisplay) plotDisplay.textContent = "No shots available for this story.";
          // Clear other script fields too
      }
  }
        }

        function changeShot(direction) {
  if (totalShots <= 0) return;
            let newIndex = currentShotIndex + direction;
  if (newIndex < 0) newIndex = totalShots - 1;
  else if (newIndex >= totalShots) newIndex = 0;
            updateExplorerView(newIndex);
        }

function handleImageClick(event) {
            if (event.target.classList.contains('sequence-image')) { 
                  const clickedShotIndex = parseInt(event.target.dataset.shotIndex);
                  if (!isNaN(clickedShotIndex) && clickedShotIndex !== currentShotIndex) {
                      updateExplorerView(clickedShotIndex);
                 }
            }
        }

        function startProgressBar() {
            let progress = 0;
            clearInterval(progressInterval);
  if(progressBar) progressBar.style.width = '0%';

            if (totalShots > 0 && progressBar) {
                progressInterval = setInterval(() => {
      progress += 100 / (autoPlayInterval / 100);
                    if (progress <= 100) {
                        progressBar.style.width = progress + '%';
                    } else {
                        clearInterval(progressInterval); 
                    }
    }, 100);
            }
        }

        function resetAutoPlayTimer() {
            clearTimeout(autoPlayTimer);
            clearInterval(progressInterval); 
            if(progressBar) progressBar.style.width = '0%'; 

            if (totalShots > 0) {
                startProgressBar(); 
                autoPlayTimer = setTimeout(() => {
      changeShot(1);
                }, autoPlayInterval);
            }
        }
        
// --- Language Change Integration ---
// The global changeLanguage is in main.js and on window.
// We enhance it for this page.
if (window.changeLanguage) {
    const originalGlobalChangeLanguage = window.changeLanguage;
    window.changeLanguage = function(lang) {
        originalGlobalChangeLanguage(lang); // Call global (updates data-lang-key elements)

        // Page-specific updates after global one runs
        if (currentStoryData && availableStories.length > 0 && currentStoryId) {
            const storyInfo = availableStories.find(s => s.id === currentStoryId);
            const titleKey = 'story_detail_title';
            const currentUiLang = document.documentElement.lang || 'en';
            let newTitleText = initialTranslations[currentUiLang]?.[titleKey] || initialTranslations.en[titleKey];
            newTitleText = newTitleText.replace('[Story ID]', storyInfo ? storyInfo.name : currentStoryId);
            
            document.title = newTitleText;
            const mainPageTitleElement = document.getElementById('story-detail-main-title');
             if (mainPageTitleElement) {
                mainPageTitleElement.textContent = newTitleText;
             } else if (storyTitleElement && storyTitleElement.tagName === 'H1') {
                storyTitleElement.textContent = newTitleText;
             }


            updateCharacterReferences(); // Update names in character refs
            // Re-render model container titles and dropdown labels
            modelResultsArea.querySelectorAll('.model-sequence-container').forEach(modelContainer => {
                const modelKey = modelContainer.dataset.modelKey;
                const titleEl = modelContainer.querySelector('h4');
                if(titleEl) {
                    const modelNameKey = `model_${modelKey}`;
                    titleEl.textContent = initialTranslations[currentUiLang]?.[modelNameKey] || initialTranslations.en?.[modelNameKey] || modelKey;
                }
                // Update dropdown labels (Mode, Language, Timestamp)
                ['mode', 'lang', 'ts'].forEach(type => {
                    const labelEl = modelContainer.querySelector(`label[for="${type}-select-${modelKey}"]`);
                    if(labelEl) {
                        // Assuming label keys like 'Mode', 'Language', 'Timestamp' or using type directly
                        let labelTextContent = initialTranslations[currentUiLang]?.[type.charAt(0).toUpperCase() + type.slice(1)] || type.charAt(0).toUpperCase() + type.slice(1);
                        labelEl.textContent = `${labelTextContent}:`;
                    }
                });
            });

            // Update current view (script text, shot indicator, etc.)
            if (totalShots > 0 && currentShotIndex >= 0 && currentShotIndex < totalShots) {
                updateExplorerView(currentShotIndex);
            }
        } else {
            // Update at least the main page title if no story is loaded yet
            const titleKey = 'story_detail_title_no_story'; // A generic title key
            const currentUiLang = document.documentElement.lang || 'en';
            let genericTitle = initialTranslations[currentUiLang]?.[titleKey] || initialTranslations.en?.[titleKey] || "Result Explorer";
            document.title = genericTitle;
            const mainPageTitleElement = document.getElementById('story-detail-main-title');
             if (mainPageTitleElement) {
                mainPageTitleElement.textContent = genericTitle;
             } else if (storyTitleElement && storyTitleElement.tagName === 'H1') {
                storyTitleElement.textContent = genericTitle;
             }
        }
    };
}


// --- Initial Load ---
async function initializeExplorer() {
  console.log("Initializing Result Explorer...");

  if(prevPageBtn) prevPageBtn.addEventListener('click', () => changeStoryPage(-1));
  if(nextPageBtn) nextPageBtn.addEventListener('click', () => changeStoryPage(1));

  try {
    const response = await fetch(`${DATA_BASE_PATH}/detailed_manifest.json`);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status} - Check if detailed_manifest.json exists.`);
    }
    detailedManifest = await response.json();
    availableStories = detailedManifest.stories || [];
    console.log("Detailed manifest loaded:", detailedManifest);

    populateStorySelector(); // Initial population

    const urlParams = new URLSearchParams(window.location.search);
    const storyIdFromUrl = urlParams.get('story');
    let storyToLoad = null;

    if (storyIdFromUrl && availableStories.some(s => s.id === storyIdFromUrl)) {
      storyToLoad = storyIdFromUrl;
      const storyIndex = availableStories.findIndex(s => s.id === storyIdFromUrl);
      if (storyIndex !== -1) {
        currentPage = Math.floor(storyIndex / storiesPerPage) + 1;
      }
      populateStorySelector(); // Repopulate to set current page correctly for cards
      await loadStory(storyToLoad);
    } else if (availableStories.length > 0) {
      storyToLoad = availableStories[0].id;
      currentPage = 1;
      // populateStorySelector(); // Already called, active card will be set by loadStory
      await loadStory(storyToLoad);
    } else {
      if(storyWallContainer) storyWallContainer.innerHTML = '<p class="text-gray-500">No stories found in manifest.</p>';
      const paginationControls = document.getElementById('story-pagination-controls');
      if(paginationControls) paginationControls.style.display = 'none';
      if(modelResultsArea) modelResultsArea.innerHTML = '<p class="text-gray-500 p-6 bg-white shadow-lg rounded-lg">No stories available.</p>';
      console.error("No stories available to load from manifest.");
    }
  } catch (error) {
    console.error("Error fetching or parsing detailed_manifest.json:", error);
    if(storyWallContainer) storyWallContainer.innerHTML = `<p class="text-red-500">Error loading story list: ${error.message}</p>`;
    if(modelResultsArea) modelResultsArea.innerHTML = '<p class="text-red-500 p-6 bg-white shadow-lg rounded-lg">Error loading configuration.</p>';
  }
}

// Ensure this runs after the DOM is fully parsed
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeExplorer);
} else {
    initializeExplorer(); // DOMContentLoaded has already fired
}

    </script>
